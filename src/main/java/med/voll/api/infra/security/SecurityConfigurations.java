package med.voll.api.infra.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

// enablewebsecurity indica que vamos personalizar as configuraÃ§Ãµes de seguranÃ§a
// sempre que precisar que o spring carregue a classe, tem que ter anotaÃ§Ã£o
@Configuration
@EnableWebSecurity
public class SecurityConfigurations {

    /*
    a gente vai sair do processo statefull para stateless
    vamos tirar a configuraÃ§Ã£o aqui do login e senha, liberou as requisiÃ§Ãµes
     */

    /*
    ðŸ›  Quando usar @Bean?
    BEAN devolve um retorno para o SPRING, para por ex mudar as configuraÃ§Ãµes
    Quando vocÃª quer registrar uma classe de fora do seu projeto, como um bean de biblioteca externa.
    Quando precisa de lÃ³gica de criaÃ§Ã£o personalizada (parÃ¢metros, condiÃ§Ãµes, etc).
    Quando quer configurar beans mais finamente (como datasources, caches, serviÃ§os, etc).
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // SecurityFilterChain Ã© usado para configurar coisas relacionadas com processo de autenticaÃ§Ã£o e autorizaÃ§Ã£o
        return http.csrf(csrf -> csrf.disable())
                .sessionManagement(sm ->
                        sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .build();
        /*
        cross-site- request forgery
        estamos desabilitando esse modo de seguranÃ§a contra request forgery, pois o token jÃ¡ Ã©
        uma forma de proteÃ§Ã£o contra esse tipo de ataque cibernÃ©tico
        ELE PRECISA DE UMA EXCEPTION, throws Exception
         */

        /*
        ALTERAR DE STATEFULL PARA STATELESS -> usar tokens
        sessionManagement abre pra ver como vai ser o gerenciamento da sessÃ£o
        sessionCreationPolicy polÃ­tica de criaÃ§Ã£o de sessÃ£o
         */
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
        return configuration.getAuthenticationManager();

        /*
        essa classe AuthenticationConfiguration tem um mÃ©todo que CRIA AuthenticationManager
        AuthenticationManager funciona pra usar os Service de Autenticacao -> AutenticacaoService
        ele precisa de uma exception
         */
    }

    /* CONFIGURANDO O BCRYPT */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
